第18章 Java I/O系统
    对程序语言的设计者来说，创建一个好的输入/输出（I/O）系统是一项艰难的任务。
    现有的大量不同方案已经说明了这一点。挑战似乎来自于要覆盖所有的可能性。不仅存在各种I/O源端和想要与之通信的接收端（文件、控制台、网络链接等），而且还需要以多种不同的方式与它们进行通信（顺序、随机存取、缓冲、二进制、按字符、按行、按字等）。
    Java类库的设计者通过创建大量的类来解决这个难题。一开始，可能会对Java I/O系统提供了如此多的类而感到不知所错。

18.1 File类
    使用类库工具，可以帮助我们处理文件目录问题。
    File（文件）类这个名字有一定的误导性；可能会认为它指代的是文件，实际上却并非如此。它既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称。如果它指的是一个文件集，我们就可以对此集合调用list()方法，这个方法会返回一个字符数组。我们很容易就可以理解返回的是一个数组而不是某个更具灵活性的类容器，因为元素的个数是固定的，所以如果我们想取得不同的目录列表，只需要再创建一个不同的File对象就可以了。实际上，FilePath(文件路径)对这个类来说是个更好的名字。

18.1.1 目录列表器
    假设我们想查看一个目录列表，可以用两种方法来使用File对象。如果我们调用不带参数的list()方法，便可以获得此File对象包含的全部列表。然而，如果我们想获得一个受限列表，例如，想得到所有扩展名为.java的文件，那么我们就要用到"目录过滤器"，这个类会告诉我们怎样显示符合条件的File对象。
18.1.2 目录实用工具
    程序设计中一项常见的任务就是在文件集上执行操作，这些文件要么在本地目录中，
要么遍布于整个目录树中。如果有一种工具能够为你产生这个文件集，那么它会非常有用。
下面的实用工具类就可以通过使用local()方法产生由本地目录中的文件构成的File对象数组，或者通过
使用walk()方法产生给定目录下的由整个目录树中所有文件构成的List<File>。这些文件是基于你提供的正则表达式而被选中的：
Directory.java

18.1.3 目录的检查及创建
    File类不仅仅只代表存在的文件或目录。也可以用File对象来创建新的目录或尚不存在的整个目录路径。我们还可以
查看文件的特性（大小、最后修改日期、读/写），检查某个File对象代表的是一个文件还是一个目录，并可以删除文件。
MakeDirectories.java

18.2 输入和输出
    编程语言的I/O类库中常使用流这个概念，它代表任何有能力产出数据的数据源对象或者是有能力接收数据的接收端对象。
“流”屏蔽了实际的I/O设备中处理数据的细节。
    Java类库中的I/O类分成输入和输出两部分，可以在JDK文档里的类层次结构中查看到。通过继承，任何自Inputstream或Reader
派生而来的类都含有名为read()的基本方法，用于读取单个字节或者字节数组。同样，任何自OutputStream或Writer派生而来的类都含有名为
writer()的基本方法，用于写单个字节或者字节数组。但是，我们通常不会用到这些方法，它们之所以存在是因为别的类可以使用它们，以便
提供更有用的接口。因此，我们很少使用单一的类来创建流对象，而是通过叠合多个对象来提供所期望的功能（这是装饰器设计模式）。实际上，Java
中"流"类库让人迷惑的主要原因就在于：创建单一的结果流，却需要创建多个对象。
    有必要按照这些类的功能对它们进行分类。在Java 1.0中，类库的设计者首先限定与输入有关的所有类都应该从InputStream继承，而与输出有关的
所有类都应该从OutputStream继承。

18.2.1 InputStream类型
    InputStream的作用是用来表示那些从不同数据源产生输入的类。如表18-1所示，这些数据源包括：
    （1）字节数组 ByteArrayInputStream
    （2）String对象 StringBufferInputStream
    （3）文件  FileInputStream
    （4）“管道”，工作方式与实际管道相似，即，从一端输入，从另一端输出。  PipedInputStream
    （5）一个由其他种类的流组成的序列，以便我们可以将它们收集合并到一个流内。 FilterInputStream
    （6）其他数据源，如Internet连接等
每种数据源都有相应的InputStream子类。另外，FilterInputStream也属于一种InputStream
，为装饰器类提供基类，其中，装饰器类可以把属性或有用的接口与输入流连接在一起。

18.2.2 OutputStream类型
    该类别的类决定了输出所要去往的目标：字节数组（但不是String，不过你当然可以用字节数组自己创建）、文件或管道。
    另外，FilterOutputStream为装饰器类提供了一个基类，装饰器类把属性或者有用的接口与输出流连接了起来。

18.3 添加属性和有用的接口
    装饰器在第15章引入。Java I/O 类库需要多种不同功能的组合，这正是使用装饰器模式的理由所在。这也是Java I/O类库里存在filter
(过滤器)类的原因所在抽象类filter是所有装饰器类的基类。装饰器必须具有和它所装饰的对象相同的接口，但它也可以扩展接口，而这种情况只发生在个别
filter类中。
    但是，装饰器模式也有一个缺点：在编写程序时，它给我们提供了相当多的灵活性，但是它同时也增加了代码的复杂性。Java I/O类库操作不变的原因在于：
我们必须创建许多类----“核心”I/O类型加上所有的装饰器，才能得到我们所希望的单个I/O对象。
    FilterInputStream和FilterOutputStream是用来提供装饰器类接口以控制特定输入流(InputStream)和输出流
(OutputStream)的两个类，它们的名字并不是很直观。FilterInputStream和FilterOutputStream分别自I/O
类库中的基类InputStream和OutputStream派生而来，这两个类是装饰器的必要条件。

18.3.1 通过FilterInputStream从InputStream读取数据
    FilterInputStream类能够完成两件完全不同的事情。其中，DataInputStream允许我们读取不同的基本类型数据以及String
对象（所有方法都以"read"开头，例如readByte()、readFloat()
等等）。搭配相应的DataOutputStream，我们就可以通过数据流将基本类型的数据从一个地方迁移到另一个地方。具体是哪些地方由表18-1中那些类决定。
    其他FilterInputStreame类则在内部修改InputStream
    的行为方式：是否缓冲，是否保留它所读过的行，以及是否把单一字符推回输入流等等。最后两个类看起来更像是为了创建一个编辑器。

18.6 I/O流的典型使用方式
    尽管可以通过不同的方式组合I/O流类，但也就只用到其中的几种组合。下面的例子可以作为典型的I/O用法的基本参考。
18.6.1 缓冲输入文件
    如果想要打开一个文件用于字符输入，可以使用以String或File对象作为文件名的FileInputReader
。为了提高速度，我们希望对那个文件进行缓冲，那么我们将所产生的引用传给一个BufferedReader构造器。由于BufferedReader
也提供readLine()方法，所以这是我们的最终对象和进行读取的接口。当readLine()将返回null时，你就达到了文件的末尾。
BufferedInputFile.java

