第18章 Java I/O系统
18.1.1 目录列表器
    示例：注意，通过使用java.util.Arrays.sort()和String.CASE_INSENSITIVE
    .ORDERComparator可以很容易地对结果进行排序（按字母顺序）。DirList.java

18.1.2 目录实用工具
    程序设计中一项常见的任务就是在文件集上执行操作，这些文件要么在本地目录中，
要么遍布于整个目录树中。如果有一种工具能够为你产生这个文件集，那么它会非常有用。
下面的实用工具类就可以通过使用local()方法产生由本地目录中的文件构成的File对象数组，或者通过
使用walk()方法产生给定目录下的由整个目录树中所有文件构成的List<File>。这些文件是基于你提供的正则表达式而被选中的：
Directory.java

18.1.3 目录的检查及创建
    File类不仅仅只代表存在的文件或目录。也可以用File对象来创建新的目录或尚不存在的整个目录路径。我们还可以
查看文件的特性（大小、最后修改日期、读/写），检查某个File对象代表的是一个文件还是一个目录，并可以删除文件。
MakeDirectories.java

18.2 输入和输出
    编程语言的I/O类库中常使用流这个概念，它代表任何有能力产出数据的数据源对象或者是有能力接收数据的接收端对象。
“流”屏蔽了实际的I/O设备中处理数据的细节。
    Java类库中的I/O类分成输入和输出两部分，可以在JDK文档里的类层次结构中查看到。通过继承，任何自Inputstream或Reader
派生而来的类都含有名为read()的基本方法，用于读取单个字节或者字节数组。同样，任何自OutputStream或Writer派生而来的类都含有名为
writer()的基本方法，用于写单个字节或者字节数组。但是，我们通常不会用到这些方法，它们之所以存在是因为别的类可以使用它们，以便
提供更有用的接口。因此，我们很少使用单一的类来创建流对象，而是通过叠合多个对象来提供所期望的功能（这是装饰器设计模式）。实际上，Java
中"流"类库让人迷惑的主要原因就在于：创建单一的结果流，却需要创建多个对象。
    有必要按照这些类的功能对它们进行分类。在Java 1.0中，类库的设计者首先限定与输入有关的所有类都应该从InputStream继承，而与输出有关的
所有类都应该从OutputStream继承。

18.2.1 InputStream类型
    InputStream的作用是用来表示那些从不同数据源产生输入的类。如表18-1所示，这些数据源包括：
    （1）字节数组 ByteArrayInputStream
    （2）String对象 StringBufferInputStream
    （3）文件  FileInputStream
    （4）“管道”，工作方式与实际管道相似，即，从一端输入，从另一端输出。  PipedInputStream
    （5）一个由其他种类的流组成的序列，以便我们可以将它们收集合并到一个流内。 FilterInputStream
    （6）其他数据源，如Internet连接等
每种数据源都有相应的InputStream子类。另外，FilterInputStream也属于一种InputStream
，为装饰器类提供基类，其中，装饰器类可以把属性或有用的接口与输入流连接在一起。

18.2.2 OutputStream类型
    该类别的类决定了输出所要去往的目标：字节数组（但不是String，不过你当然可以用字节数组自己创建）、文件或管道。
    另外，FilterOutputStream为装饰器类提供了一个基类，装饰器类把属性或者有用的接口与输出流连接了起来。

18.3 添加属性和有用的接口
    装饰器在第15章引入。Java I/O 类库需要多种不同功能的组合，这正是使用装饰器模式的理由所在。这也是Java I/O类库里存在filter
(过滤器)类的原因所在抽象类filter是所有装饰器类的基类。装饰器必须具有和它所装饰的对象相同的接口，但它也可以扩展接口，而这种情况只发生在个别
filter类中。
    但是，装饰器模式也有一个缺点：在编写程序时，它给我们提供了相当多的灵活性，但是它同时也增加了代码的复杂性。Java I/O类库操作不变的原因在于：
我们必须创建许多类----“核心”I/O类型加上所有的装饰器，才能得到我们所希望的单个I/O对象。
    FilterInputStream和FilterOutputStream是用来提供装饰器类接口以控制特定输入流(InputStream)和输出流
(OutputStream)的两个类，它们的名字并不是很直观。FilterInputStream和FilterOutputStream分别自I/O
类库中的基类InputStream和OutputStream派生而来，这两个类是装饰器的必要条件。

18.3.1 通过FilterInputStream从InputStream读取数据
    FilterInputStream类能够完成两件完全不同的事情。其中，DataInputStream允许我们读取不同的基本类型数据以及String
对象（所有方法都以"read"开头，例如readByte()、readFloat()
等等）。搭配相应的DataOutputStream，我们就可以通过数据流将基本类型的数据从一个地方迁移到另一个地方。具体是哪些地方由表18-1中那些类决定。
    其他FilterInputStreame类则在内部修改InputStream
    的行为方式：是否缓冲，是否保留它所读过的行，以及是否把单一字符推回输入流等等。最后两个类看起来更像是为了创建一个编辑器。

18.6 I/O流的典型使用方式
    尽管可以通过不同的方式组合I/O流类，但也就只用到其中的几种组合。下面的例子可以作为典型的I/O用法的基本参考。
18.6.1 缓冲输入文件
    如果想要打开一个文件用于字符输入，可以使用以String或File对象作为文件名的FileInputReader
。为了提高速度，我们希望对那个文件进行缓冲，那么我们将所产生的引用传给一个BufferedReader构造器。由于BufferedReader
也提供readLine()方法，所以这是我们的最终对象和进行读取的接口。当readLine()将返回null时，你就达到了文件的末尾。
BufferedInputFile.java
