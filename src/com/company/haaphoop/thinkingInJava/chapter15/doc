第15章 泛型
一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用与多种类型的代码，这种刻板的限制对代码的束缚就会很大。

java泛型的核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一起细节。

15.2.1 一个元祖类库
    仅一次方法调用就能返回多个对象，你应该经常需要这样的功能吧。可是return
语句只允许返回单个对象，因此，解决办法就是创建一个对象，用他来持有想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。可是有了泛型，我们
就能够一次性地解决该问题，以后再也不用在这个问题上浪费时间了。同时，我们在编译器就能够确保类型安全。
    这个概念称为元祖，它是将一组对象直接打包存储于其中的一个单一对象。这个容器对象允许读取其中元素，但是不允许向其中存放新的对象。
    通常，元祖可以具有任意长度，同时，元祖中的对象可以是任意不同的类型。

15.2.2 一个堆栈类

15.2.3 RandomList
    作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用其上的select()
    方法时，它可以随机地选取一个元素。如果我们希望以此构建一个可以应用于各种类型的对象的工具时，就需要使用泛型：

15.3 泛型接口

通过继承创建适配器：

15.4 泛型方法
 到目前为止，我们看到的泛型，都是应用于整个类上。但同样可以在勒种包含参数化方法，而这个方法所在的类可以是泛型类，也可以不是泛型类。也就是说，是否拥有泛型方法，
 与其所在的类是否时泛型没有关系。
 泛型方法使得该方法嫩巩固独立于类而产生变化。以下是一个基本的指导原则：无论何时，只要你能做到，你就应该尽量使用泛型方法。
 也就是说，如果使用泛型方法可以取代将整个类繁星花，那么就应该只使用泛型方法，因为它可以使事情更清楚明白。另外，对于一个static
 的方法而言，无法访问泛型类的类型参数，所以，如果static方法需要使用泛型能力，就必须使其成为泛型方法。
 要定义泛型方法，只需将泛型参数列表置于返回值之前，就像下面这样：
 public class GenericMethods {
    public <T> void f(T t) {
        System.out.println(t.getClass.getName());
    }
 }

 15.4.1 杠杆利用类型参数推断
 人们对泛型有一个抱怨，使用泛型有时候需要向程序中加入更多的代码。
 类型推断只对赋值操作有效，其他时候并不起作用。如果你将一个泛型方法调用的结果作为参数，传递给令一个方法，这时编译器并不会执行类型
 推断。在这种情况下，编译器认为：调用泛型方法后，其返回值被赋予给一个Object类型的变量。例子：LimitsOfInterface.java

 显式的类型说明
 在泛型方法中，可以显式地指明类型，不过这种语法很少使用。要显式地指明类型，必须在点操作符与方法名之间插入尖括号，然后把类型置于尖括号内。如果是在定义该
 方法的类的内部，必须在点操作符之前使用this关键字，如果是使用static的方法，必须在点操作符之前加上类名。

 15.4.2 可变参数与泛型方法
 泛型方法与可变参数列表能够很好地共存：GenericVarargs.java

 15.4.3 用于Generator的泛型语法
 利用生成器，我们可以很方便地填充一个Collection，而泛型化这种操作是具有实际意义的；Generators.java

15.4.4 一个通用的Generator
下面的程序可以为任何类构造一个Generator，只要该类具有默认的构造器。为了减少类型声明，它提供了一个泛型方法，用以生成BasicGenerator:

15.4.5 简化元祖的使用
    有了类型参数推断，再加上static方法，我们可以重新编写之前看到的元祖工具，使其成为更通用的工具类库。在这个类中，我们通过重载static
    方法创建元祖：Tuple.java

15.4.6 一个Set实用工具
    作为泛型方法的另一个示例，我们看看如何用Set来表达数学中的关系式。通过使用泛型方法，可以很方便地做到这一点，而且可以应用于多种类型：Sets.java

15.5 匿名内部类
泛型还可以应用于内部类以及匿名内部类。
下面的示例使用匿名内部类实现了Generator接口:Customer.java

15.6 构建复杂模型
    泛型的一个重要好处使能够简单而安全地创建复杂的模型。例如，我们可以很容易地创建List元祖：TupleList.java

15.7 擦除得神秘之处
    当你开始更深入地专研泛型时，会发现有大量得东西初看起来是没有意义得。例如，尽管可以声明ArrayList
    .class，但是不能声明Arraylist<Integer>.class。请考虑下面得情况：ErasedTypeEquivalence.java
    ArrayList<String>和ArrayList<Integer
    >很容易被认为是不同得类型。不同得类型在行为方面肯定不同，例如，如果尝试着将一个Integer放入ArrayList<String>,
    所得到得行为（将失败）与把一个Integer放入ArrayList<Integer
    >（将成功）所得到得行为完全不同。但是上面得程序会认为它们是相同得类型。
    下面得示例是对这个谜题得一个补充：LostInformation.java