第14章 类型信息
运行时类型信息使得你可以在程序运行时发现和使用类型信息。
它使你从只能在编译期执行面向类型的操作的禁锢中解脱了出来，并且可以使用某些非常强大的程序。对RTTI的需要，
揭示了面向对象设计中许多有趣的问题，同时也提出了如何组织程序的问题。
本章将讨论Java是如何让我们在运行时识别对象和类的信息的。主要有两种方式：一种是“传统的”RTTI，它假定我们在编译时
已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。

14.1 为什么需要RTTI
面向对象编程中基本目的是：让代码只操纵对基类的引用。

14.2 Class对象
Class对象就是用来创建类的所有的“常规”对象的。Java使用Class对象来执行其RTTI。Class类还拥有大量的使用RTTI的其他方式。
类是程序的一部分，每个类都有一个Class对象。换言之，每当编写并且编译了一个新类，就会产生一个Class对象。为了生成这个类的对象，运行这个程序的Java虚拟机将使用被称为类加载器的子系统。
类加载器子系统实际上可以包含一条类加载器链，但是只有一个原生类加载器，它是JVM实现的一部分。原生类加载器加载的是所谓的可信类，包括Java API类，它们通常是从本地盘加载的。在这条链中，通常不需要添加额外的类加载器。
所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。这个证明构造器也是类的静态方法，即使在构造器之前并没有使用static关键字。因此，使用new操作符创建类的新对象也会被当作对类的静态成员的引用。
因此，Java程序在它开始运行之前并非被完全加载，其各个部分实在必须时才加载的。类加载器首先检查这个类的Class对象是否已经加载。如果尚未加载，默认的类加载器就会根据类名查找.class文件。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良Java代码。一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象。

14.2.1 类字面常量
Java还提供了另一种方法来生成对Class对象的引用，即使用类字面常量。如：FancyToy.class;这样做不仅更简单，而且更安全，因为它在编译时就会受到检查（因此不需要置于try语句块中）。并且它根除了对forName()方法的调用，所以更高效。
类字面常量不仅可以应用于普通的类，也可以应用于接口、数组以及基本数据类型。另外，对于基本数据类型的包装器类，还有一个标准字段TYPE。TYPE字段时一个引用，指向对应的基本数据类型的Class对象
当使用".class"来创建对Class对象的应用时，不会自动地初始化该Class对象。为了使用类而做的准备工作实际包含三个步骤：
    1）加载，这是有类加载器执行的。该步骤将查找字节码（通常在classpath所指定的路径中查找，但这并非是必需的），并从这些字节码中创建一个Class对象。
    2）链接。在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类创建的对其他类的所有引用。
    3）初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。
初始化被延迟到了对静态方法（构造器隐式地是静态的）或者非常数静态域进行首次引用时才执行

14.2.2 泛化的Class引用
Class引用总是指向某个Class对象，它可以制造类的实例，并包含可作用域这些实例的所有方法代码。它还包含该类得静态成员，因此，Class引用表示得就是它所指向得对象得确切类型，而该对象便是Class类的一个对象。

14.2.3 新的转型语法
Java SE5添加了用于Class引用的转型语法，即cast()方法：

14.3 类型转换前先做检查
迄今为止，我们已经知道RTTI形式包括：
1）传统的类型转换，如"(Shape)",由RTTI确保类型转换的正确性，如果执行了一个错误的类型
转换，就会抛出一个ClassCastException异常。
2）代表对象的类型的Class对象。通过查询Class对象可以获取运行时所需的信息。
RTTI在Java中还有第三种形式，就是关键字instanceof。它返回一个布尔值，告诉我们对象是不是某个
特定类型的实例。可以用提问的方式使用它，就像这样：
if (x instanceof Dog) {
    ((Dog)x).bark();
}
在将x转型成一个Dog前，上面的if语句会检查对象x是否从属于Dog类。进行向下转型前，如果没有其他信息
可以告诉你这个对象是什么类型，那么使用instanceof是非常重要的，否则会得到一个ClassCastException异常。
一般，可能想要查找某种类型，这时可以轻松地使用instanceof来计数所有对象。例如，假设你有一个类的继承体系，描述了Pet
（以及它们的主人，这是在后面的示例中出现的一个非常方便的特性）。在这个继承体系中的每个Individual都有一个id和一个可选的名字。
尽管下面的类都继承自Individual，但是Individual类复杂性较高，因此其代码将放到第17章中进行说明与解释。正如你可以看到的，此处并不需要去了解
Individual的代码---你只需要了解你可以创建其具名或不具名的对象，并且每个Individual都有一个id()
方法，可以返回其唯一的标识符（通过对每个对象计数而创建的）。还有一个toString()方法，如果你没有为Individual提供名字，toString()
方法只产生类型名。

14.3.1 使用类字面常量

14.4 注册工厂
生成Pet继承结构中的对象存在着一个问题，即每次向该继承结构添加新的Pet类型时，必须将其添加为LiteralPetCreator.java中的项。
如果在系统中已经存在了继承结构的常规的基础，然后在其上要添加更多的类，那么就有可能会出现问题。
    你可能会考虑在每个子类中添加静态初始化器，以使得该初始化器可以将它的类添加到其某个List中。遗憾的是，静态初始化器
只有在类首次被加载的情况下才能被调用，因此你就碰上了“先有鸡还是先有蛋”的问题：生成器在其列表中不包含这个类，因此它永远
不能创建这个类的对象，而这个类也就不能被加载并至于这个列表中。
    这主要是因为，你被强制要求自己去手工创建这个列表。因此，你最佳的做法是，将这个列表置于一个位于中心的、位置明显的地方，
而我们感兴趣的继承结构的基类可能就是这个最佳位置。
    这里我们需要做的其他修改就是使用工厂方法设计模式，将对象的创建工作交给类自己去完成。工厂方法可以被多态地调用，从而为你创建
恰当类型的对象。

14.5 instanceof 与Class的等价性
在查询类型信息时，以instanceof 的形式(即以instanceof的形式或isInstance()的形式，它们产生相同的结果)与直接比较Class对象

14.6 反射：运行时的类信息
如果不知道某个对象的确切类型，RTTI可以告诉你。但是有一个限制：这个类型在编译时必须知己，这样才能使用RTTI
识别它，并利用这些信息做一些有用的事。换句话说，在编译时，编译器必须知道所有要通过RTTI来处理的类。
    初看起来这似乎不是个限制，但是假设你获取了一个指向某个并不在你的程序空间中的对象的引用；事实上，在编译时你的程序
根本没法获知这个对象所属的类。例如，假设你从磁盘文件，或者网络连接中获取了一串字节，并且你被告知这些字节代表了一个类。
既然这个类在编译器为你的程序生成代码之后很久才会出现，那么怎样才能使用这样的类呢？
    Class类与java.lang.reflect类库一起对反射的概念进行了支持，该类库包含了Field、Method以及Constructor
    类（每个类都实现了Member接口）。这些类型的对象是由JVM在运行时创建的，用以表示未知类里对应的成员。这样你就可以使用Constructor创建
    新的对象，用get()和set()方法读取和修改与Field对象关联的字段，用invoke()
    方法调用与Method对象关联的方法。另外，还可以调用getFileds()、getMethods()和getConstructors()
    等很便利的方法，以返回表示字段、方法以及构造器的对象的数组。这样，匿名对象的类信息就能在运行时被完全确定下来，而在编译时不需要知道任何事情。
    重要的是，要认识到反射机制并没有什么神奇之处。当通过反射与一个未知类型的对象打交道时，JVM
    只是简单地检查这个对象，看它属于哪个特定的类。在用它做其他事情之前必须先加载那个类的Class对象。因此，那个类的
    .class文件对于JVM来说必须时可获取的：要么在本地机器上，要么可以通过网络取得。所以RTTI和反射之间真正的区别只在于，对RTTI
    来说，编译器在编译时打开和检查.class文件。而对于反射机制来说，.class文件在编译时是不可获取的，所以实在运行时打开和检查.class文件。

14.6.1 类方法提取器
通常不需要直接使用反射工具，但是它们在需要创建更加动态的代码时会很有用。反射在Java中是用来支持其他特性的，例如对象序列化和JavaBean。但是，
如果能动态地提取某个类的信息有的时候还是很有用的。请考虑方法提取器。浏览实现了类定义的源代码或其JDK文档，只能找到在这个类定义中被定义或被覆盖的方法。但
对你来说，可能有数十个更有用的方法都是继承自基类的。

14.7 动态代理
代理是基本得设计模式之一，它是你为了提供额外的或不同的操作，而插入的用来代替“实际”对象的对象。这些操作通常涉及与“实际”对象的通信，因此代理
通常充当着中间人的角色。
在任何时刻，只要你想要将额外的操作从"实际"对象中分离到不同的地方，特别是当你希望能够很容易地做出修改，从没有使用额外操作转为使用这些操作，或者反过来时，代理就
显得很有用（设计模式的关键就是封装修改--因此你需要修改事务以证明这种模式的正确性）。例如，如果你希望跟踪对RealObject
中的方法的调用，或者希望度量这些调用的开销，那么你应该怎样做呢？这些代码肯定是你不希望将其合并到应用中的代码，因此代理使的你可以很容易地添加或移除它们。
Java
的动态代理比代理的思想更向前迈进了一部，因为它可以动态地创建代理并动态地处理对所代理方法的调用。在动态代理商所做的所有调用都会被重定向到单一的调用处理器上，
它的工作是揭示调用的类型并确定相应的对策。下面是动态代理重写的SimpleProxyDemo.java

14.8 空对象
    当你使用内置的null表示缺少对象时，在每次使用引用时都必须测试其是否为null，这显得枯燥，而且势必产生相当乏味的代码。问题在于null
除了在你试图用它执行任何操作来产生NullPointerException之外，它自己没有其他任何行为。有时引入空对象的思想将会很有用，它可以接受传递给
它的所代表的对象的信息，但是将返回表示为实际上并不存在任何“真实对象的值”。通过这种方式，你可以假设所有的对象都是有效的，而不必浪费编程精力去检查null。
    尽管想象一种可以自动为我们创建空对 象的编程语言显得很有趣，但是实际上，到处使用空对象并没有任何意义--有时检查null
    就可以了，有时你可以合理地假设你根本不会遇到null，有时甚至通过NullPointerException
    来探测异常也可以接受的。空对象最有用之处在于它更靠近数据，因为对象表示的是问题空间内的实体。有一个简单的例子，许多系统都有一个Person
    类，而在代码中，有很多情况是你没有一个实际的人。因此，通常你会使用一个null
    引用并测试它。与此不同的是，我们使用空对象。但是即使空对象可以相应“实际”对象可以相应的所有消息，你仍需要某种方式去测试其是否为空。要达到此目的，最简单的方式是创建一个标记接口：
    public interface Null{}
    这使得instanceof可以探测空对象，更重要的是，这并不要求你在所有的类中都添加isNull()方法




