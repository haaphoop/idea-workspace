第14章 类型信息
运行时类型信息使得你可以在程序运行时发现和使用类型信息。
它使你从只能在编译期执行面向类型的操作的禁锢中解脱了出来，并且可以使用某些非常强大的程序。对RTTI的需要，
揭示了面向对象设计中许多有趣的问题，同时也提出了如何组织程序的问题。
本章将讨论Java是如何让我们在运行时识别对象和类的信息的。主要有两种方式：一种是“传统的”RTTI，它假定我们在编译时
已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。

14.1 为什么需要RTTI
面向对象编程中基本目的是：让代码只操纵对基类的引用。

14.2 Class对象
Class对象就是用来创建类的所有的“常规”对象的。Java使用Class对象来执行其RTTI。Class类还拥有大量的使用RTTI的其他方式。
类是程序的一部分，每个类都有一个Class对象。换言之，每当编写并且编译了一个新类，就会产生一个Class对象。为了生成这个类的对象，运行这个程序的Java虚拟机将使用被称为类加载器的子系统。
类加载器子系统实际上可以包含一条类加载器链，但是只有一个原生类加载器，它是JVM实现的一部分。原生类加载器加载的是所谓的可信类，包括Java API类，它们通常是从本地盘加载的。在这条链中，通常不需要添加额外的类加载器。
所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。这个证明构造器也是类的静态方法，即使在构造器之前并没有使用static关键字。因此，使用new操作符创建类的新对象也会被当作对类的静态成员的引用。
因此，Java程序在它开始运行之前并非被完全加载，其各个部分实在必须时才加载的。类加载器首先检查这个类的Class对象是否已经加载。如果尚未加载，默认的类加载器就会根据类名查找.class文件。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良Java代码。一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象。

14.2.1 类字面常量
Java还提供了另一种方法来生成对Class对象的引用，即使用类字面常量。如：FancyToy.class;这样做不仅更简单，而且更安全，因为它在编译时就会受到检查（因此不需要置于try语句块中）。并且它根除了对forName()方法的调用，所以更高效。
类字面常量不仅可以应用于普通的类，也可以应用于接口、数组以及基本数据类型。另外，对于基本数据类型的包装器类，还有一个标准字段TYPE。TYPE字段时一个引用，指向对应的基本数据类型的Class对象
当使用".class"来创建对Class对象的应用时，不会自动地初始化该Class对象。为了使用类而做的准备工作实际包含三个步骤：
    1）加载，这是有类加载器执行的。该步骤将查找字节码（通常在classpath所指定的路径中查找，但这并非是必需的），并从这些字节码中创建一个Class对象。
    2）链接。在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类创建的对其他类的所有引用。
    3）初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。
初始化被延迟到了对静态方法（构造器隐式地是静态的）或者非常数静态域进行首次引用时才执行

14.2.2 泛化的Class引用
Class引用总是指向某个Class对象，它可以制造类的实例，并包含可作用域这些实例的所有方法代码。它还包含该类得静态成员，因此，Class引用表示得就是它所指向得对象得确切类型，而该对象便是Class类的一个对象。

14.2.3 新的转型语法
Java SE5添加了用于Class引用的转型语法，即cast()方法：

14.3 类型转换前先做检查
迄今为止，我们已经知道RTTI形式包括：
1）传统的类型转换，如"(Shape)",由RTTI确保类型转换的正确性，如果执行了一个错误的类型
转换，就会抛出一个ClassCastException异常。
2）代表对象的类型的Class对象。通过查询Class对象可以获取运行时所需的信息。
RTTI在Java中还有第三种形式，就是关键字instanceof。它返回一个布尔值，告诉我们对象是不是某个
特定类型的实例。可以用提问的方式使用它，就像这样：
if (x instanceof Dog) {
    ((Dog)x).bark();
}
在将x转型成一个Dog前，上面的if语句会检查对象x是否从属于Dog类。进行向下转型前，如果没有其他信息
可以告诉你这个对象是什么类型，那么使用instanceof是非常重要的，否则会得到一个ClassCastException异常。
一般，可能想要查找某种类型，这时可以轻松地使用instanceof来计数所有对象。例如，假设你有一个类的继承体系，描述了Pet
（以及它们的主人，这是在后面的示例中出现的一个非常方便的特性）。在这个继承体系中的每个Individual都有一个id和一个可选的名字。
尽管下面的类都继承自Individual，但是Individual类复杂性较高，因此其代码将放到第17章中进行说明与解释。正如你可以看到的，此处并不需要去了解
Individual的代码---你只需要了解你可以创建其具名或不具名的对象，并且每个Individual都有一个id()
方法，可以返回其唯一的标识符（通过对每个对象计数而创建的）。还有一个toString()方法，如果你没有为Individual提供名字，toString()
方法只产生类型名。

14.3.1 使用类字面常量

14.4 注册工厂
生成Pet继承结构中的对象存在着一个问题，即每次向该继承结构添加新的Pet类型时，必须将其添加为LiteralPetCreator.java中的项。
如果在系统中已经存在了继承结构的常规的基础，然后在其上要添加更多的类，那么就有可能会出现问题。
    你可能会考虑在每个子类中添加静态初始化器，以使得该初始化器可以将它的类添加到其某个List中。遗憾的是，静态初始化器
只有在类首次被加载的情况下才能被调用，因此你就碰上了“先有鸡还是先有蛋”的问题：生成器在其列表中不包含这个类，因此它永远
不能创建这个类的对象，而这个类也就不能被加载并至于这个列表中。
    这主要是因为，你被强制要求自己去手工创建这个列表。因此，你最佳的做法是，将这个列表置于一个位于中心的、位置明显的地方，
而我们感兴趣的继承结构的基类可能就是这个最佳位置。
    这里我们需要做的其他修改就是使用工厂方法设计模式，将对象的创建工作交给类自己去完成。工厂方法可以被多态地调用，从而为你创建
恰当类型的对象。



