package com.company.haaphoop.thinkingInJava;

/**
 * @Description:
 * @Author: daishuli
 * @Date: Create in 2017/6/20 21:45
 * @Modified:
 */
public class Chapter5 {
    /*
        5.1 用构造器确保初始化
            不接受任何参数的构造器称为默认构造器
        5.2 方法重载
            方法名相同形式参数不同
            5.2.1 区分重载方法
                每个重载方法都必须有独一无二的参数类型列表
            5.2.2 涉及基本类型的重载
                基本类型能从一个较小的类型自动提升至一个较大的类型，可能会造成一定的混淆
                如果传入的数据类型小于方法中形式参数的类型，实际数据类型就会被提升。char类型略有不同，
                如果无法找到恰好接收char参数的方法，就会把char直接提升至int类型。如果传入的实际参数较大，
                就得通过类型转换来窄化转换。
        5.3 默认构造器
            默认构造器是没有参数的-它的作用是创建一个默认对象。如果类中没有构造器，编译器会自动创建一个
            默认构造器。但是如果已经定义了一个构造器（无论是否有参数），编译器就不会自动创建默认构造器

        5.4 this关键字
            在方法内部获得对当前对象的引用。方法内部调用同一个类的另一个方法，不必使用this，编译器会自动添加
            5.4.1 在构造器中调用构造器
                在构造器中，为this添加了参数列表，表示对符合参数列表的某个构造器的明确引用。只可以用this调用
                一个构造器，不能调用多个。必须将构造器调用置于最起始处，否则编译器会报错。
            5.4.2 static 的含义
                static的方法就是没有this的方法。

        5.5 清理：终结处理和垃圾回收
            5.5.4 垃圾回收器如何工作
                    垃圾回收器对于提高对象的创建速度，具有明显的效果。
                    在某些java虚拟机中，堆的实现截然不同：更像一个传送带，每分配一个新对象，它就往前移动一格，意味着
                    对象存储空间的分配速度非常快。java的“堆指针”只是简单的移动到尚未分配的区域。当它工作时，将一面回收空间
                    一面使堆中的对象紧凑排列，这样“堆指针”就可以很容易移动到更靠近传送带的开始处，尽量避免了页面错误。通过
                    垃圾回收器对对象的重新排列，实现了一种高速的有无线空间可供分配的堆模型。
                    引用计数是一种简单但速度很慢的垃圾回收技术。每个对象都含有一个引用计数器，当有引用连接至对象时，
                    引用计数加1。当引用离开作用域或被置为null时，引用计数减1。虽然管理引用计数的开销不大，但这项开销在
                    整个程序生命周期中将持续发生。垃圾回收器会在含有全部对象的列表上进行遍历，当发现某个对象的引用计数为0
                    时，就释放其占用的空间（但是，引用计数模式经常会在计数值变为0时立即释放对象）。这种做法有个缺陷，如果对象之间
                    存在循环引用，可能会出现“对象应该被回收，但引用计数却不为0”的情况。引用计数常用来说明垃圾收集的工作方式
                    ，但似乎从未被应用于任何一种java虚拟机实现中。

                    在一些更快的模式中，垃圾回收器并非基于引用计数技术。它们依据的思想是：对任何“活”的对象，一定能最终追溯
                    到其存活在堆栈或静态存储区之中的引用。这个引用链条可能穿过数个对象的层次。由此，如果从堆栈或静态存储区
                    开始，遍历所有的引用，就能找到所有“活”的对象。对于发现的每个引用，必须追踪它所引用的对象，然后是此对象
                    所包含的所有引用，如此反复进行，直到“根源于堆栈和静态存储区的引用”所形成的网络全部被访问为止。

    */
}

class Rock{
    public Rock() {
        System.out.println("Rock");
    }

    static void f(String s, int i) {
        System.out.println("String: " + s + "Integer: " + i);
    }

    static void f(int i, String s){
        System.out.println( "Integer: " + i + "String: " + s);
    }
}

class SimpleConstructor{
    public static void main(String[] args){
        for (int i = 0; i < 10; i++) {
            new Rock();

        }
        Rock.f(9,"dfasf");
        Rock.f("fdsaf",0);
    }
}
