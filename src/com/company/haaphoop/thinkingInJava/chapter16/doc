第16章 数组
对数组得基本看法是，你可以创建并组装它们，通过使用整型索引值访问它们得元素，并且它们得尺寸不能改变。在大多数时候，
这就是你需要了解得全部。但是有时你需要在数组上执行更加复杂得操作，并且你可能需要评估到底是使用数组还是更加灵活得容器。

16.1 数组为什么特殊
Java中有大量其他得方式可以持有对象，那么到底是什么使数组变得与众不同呢？
数组与其他种类得容器之间得区别有三方面：效率、类型和保存基本类型得能力。在Java中，数组是一种效率最高得存储和随机访问对象
引用序列得方式。数组就是一个简单得线性序列，这使得元素访问非常快速。但是为这种速度所付出得代价是数组对象得大小被固定，并且在其生命周期中不可改变。你可能会建议使用ArrayList，它可以通过创建一个
新示例，然后把旧实例中所有得引用移到新实例中，从而实现更多空间得自动分配。尽管通常应该首选ArrayList
而不是数组，但是这种弹性需要开销，因此，ArrayList的效率比数组低很多。
    数组和容器都可以保证你不能滥用它们。无论你是使用数组还是容器，如果越界，都会得到表示程序员错误的RuntimeException异常。
    在泛型之前，其他的容器类在处理对象使，都将它们视作没有任何具体类型。也就是说，它们将这些对象都当做Java中所有类的根类Object处理。数组之所以
优于泛型之前的容器，就是因为你可以创建一个数组去持有某种具体类型。这意味着你可以通过编译器检查，来防止插入错误类型和抽取不当类型。当然，无论在编译时还是运行时，java都会阻止你向对象发送不恰当的消息。所以，并不是说哪种方法更安全，只是如果
编译时就能够指出错误，会显得更加优雅，也减少了程序的使用者被异常吓着的可能性。
    数组可以持有基本类型，而泛型之前的容器则不能。但是有了泛型，容器就可以指定并检查它们所持有对象的类型，并且有了自动包装机制，容器看起来还能够
持有基本类型。下面是将数组与泛型容器进行比较的示例：BerylliumSphere.java

16.2 数组是一级对象
    无论使用哪种类型的数组，数组标识符其实是一个引用，指向在堆中创建的一个真实对象，这个（数组）对象用以保存指向其他对象的引用。可以作为数组初始化语法的一部分隐式地创建此对象，或者
    用new表达式显式地创建。只读成员length是数组对象的一部分，表示此数组对象可以存储多少元素。“[]”语法是访问数组对象的唯一方式。
    下例总结了初始化数组的各种方式，以及如何对指向数组的引用赋值，使之指向另一个数组对象。此例也说明，对象数组和基本类型数组在使用上几乎是相同的；唯一的区别就是对象数组保存的是引用，基本类型
    数组直接保存基本类型的值。ArrayOptions.java

16.3 返回一个数组
假设你要写一个方法，而且希望它返回的不止一个值，而是一组值。
在Java中，你只是直接“返回一个数组”，而无需担心要为数组负责---只要你需要它，它就会一直存在，当你使用完后，垃圾回收器会清理掉它。
下面演示如何返回String型数组：IceCream.java

16.4 多维数组
创建多维数组很方便。对于基本类型的多维数组，可以通过使用花括号将每个向量分隔开：MultidimensionalPrimitiveArray.java

16.5 数组与泛型
    通常，数组与泛型不能很好地结合。你不能实例化具有参数化类型的数组：
    Peel<Banana>[] peels = new Peel<Banana>[10]; //Illegal
    擦除会移除参数类型信息，而数组必须知道它们所持有的确切类型，以强制保证类型安全。
    但是，你可以参数化数组本身的类型：ClassParameter.java
    注意，使用参数化方法而不使用参数化类的方便之处在于：你不必为需要应用的每种不同的类型都使用一个参数去实例化这个类，并且
你可以将其定义为静态的。当然，你不能总是选择使用参数化方法而不是参数类，但是它应该成为首选。
正如上例所证明的那样，不能创建泛型数组这一说法并不十分准确。诚然，编译器确实不让你实例化泛型数组，但是，它允许你创建对这种数组的引用。例如：List
<String>[] ls;
这条语句可以顺利地通过编译器而不报任何错误。而且，尽管你不能创建实际持有泛型的数组对象，但是你可以创建非泛型的数组，然后将其转型：ArrayOfGenerics
.java

16.6 创建测试数据
通常，在试验数组和程序时，能够很方便地生成填充了测试数据的数组，将会很有帮助。本节介绍的工具就可以用数值或对象来填充数组。

16.6.1 Arrays.fill()
    Java标准类库Arrays有一个作用十分有限的fill()
    方法：只能用同一个值填充各个位置，而针对对象而言，就是复制同一个引用进行填充。FillingArrays.java

16.6.2 数据生成器
    为了以灵活的方式创建更有意义的数组，我们将使用在第15章中引入的Generator概念。
如果某个工具使用了Generator，那么你就可以通过选择Generator
的类型来创建任何类型的数据。（这是策略设计模式的一个实例--每个不同的Generator都表示一个不同的策略）。
    本节将提供一些Generator，并且，就像之前看到的，你还可以很容易地定义自己的Generator。
     首先给出的是可以用于所有基本类型的包装器类型，以及String类型的最基本的计数器生成器集合。这些生成器类都嵌套在CountingGenerator
 类中，从而使得它们能够使用与所要生成的对象类型相同的名字。例如，创建Integer对象的生成器可以通过表达式new CountingGenerator
 .Integer()来创建：CountingGenerator.java