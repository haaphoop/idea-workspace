11 持有对象
如果一个程序只包含固定数量的且其生命周期都是已知的对象，那么这是一个非常简单的程序。
通常，程序总是根据运行时才知道的某些条件去创建新对象。在此之前，不会知道所需对象的数量，甚至不知道
确切的类型。为解决这个普遍的变成问题，需要在任意时刻和任意位置创建任意数量的对象。所以，就不能依靠创建命名的引用来持有每一个对象。
因为你不知道实际上会需要多少这样的引用。
大多数语言都提供某种方法来解决这个基本问题。Java有多种方式保存对象（应该说是对象的引用）。例如前面曾经学习过的数组，它是
编译器支持的类型。数组是保存一组对象的最有效的方式，如果你想保存一组基本类型数据，也推荐使用这种方式。但是数组具有固定的尺寸
，而在更一般的情况中，你在写程序时并不知道将需要多少个对象，或者是否需要更复杂的方式来存储对象，因此数组尺寸固定这一限制
显得过于受限了。
Java的实用类库还提供了一套相当完整的容器来解决这个问题，其中基本的类型是List、Set、Quene和Map。这些对象类型也
称为集合类，但由于Java的类库中使用了Collection这个名字来指代该类库的一个特殊子集，所以我使用了更广泛的术语“容器”
称呼他们。容器提供了完善的方法来保存对象，你可以使用这些工具来解决数量惊人的问题。
容器还有其他一些特性。例如，set对于每个值都只保存一个对象，map是允许你将某些对象与其他一些对象关联起来的关联数组。
java容器类都可以自动地调整自己的尺寸。因此，与数组不同，在编程时，你可以将任意数量的对象放置到容器中，并且不需要担心
容器应该设置多大。
即使在java中没有直接的关键字支持，容器类仍旧是可以显著增强你的编程能力的基本工具。

11.1 泛型和类型安全的容器
使用javaSE5之前的容器的一个主要问题是编译器允许你向容器中插入不正确的类型。例如，考虑一个Apple对象的容器，我们使用
最基本最可靠的容器ArrayList。现在你可以把ArrayList当作“可以自动扩充自身尺寸的数组”来看待。使用ArrayList相当
简单：创建一个实例，用Add()方法插入对象，然后使用get()访问这些对象，此时需要使用索引，就像数组一样，但是不需要
方括号。ArrayList还有一个size方法，使你可以知道已经有多少元素添加了进来，从而不会因为不小心索引越界而引发错误。
在本例中，Apple和Orange都放置在了容器中，然后将它们取出。正常情况下，java编译器会报告警告信息，因为这个示例没有使用
泛型。在这里，我们使用JavaSE5所特有的注解来抑制了警告信息。注解以“@”符号开头，可以接受参数，这里的@SuppressWarnings
注解及其参数表示只有有关“不受检查的异常”的警告信息应该被抑制。

11.2 基本概念
Java容器类类库的用途是“保存对象”，并将其划分为两个不同的概念：
1）Collection。一个独立元素的序列，这些元素都服从一条或多条规则。list必须按照插入的顺序保存元素，而set不能有
重复的元素。queue按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。
2）Map。一组成对的“键值对”对象，允许你使用键来查找值。ArrayList允许你使用数字来查找值，因此在某种意义上讲，它
将数字与对象关联在了一起。映射表允许我们使用另一个对象来查找某个对象，它也被称为“关联数组”。因为它将某些对象
与另一些对象关联在了一起；或者被称为“字典”，因为你可以使用键对象来查找值对象，就像在字典中使用单词来定义一样。
Map是非常强大的编程工具。
    尽管并非总是这样，但是在理想情况下，你编写的大部分代码都是在与这些接口打交道，并且你唯一需要指定所使用
    的精确类型的地方就是在创建的时候。因此，你可以像下面这样创建一个list:
    List<Apple> apples = new ArrayList<Apple>();
    注意，ArrayList已经被向上转型为List,这与前一个示例中的处理方式正好相反。使用接口的目的在于如果你决定去修改
    你的实现，你所需的只是在创建处修改它，就像下面这样：
    List<Apple> apples = new LinkedList<Apple>();
    因此，你应该创建一个具体类的对象，将其转型为对应的接口，然后在其余的代码中都使用这个接口。这种方式并非
    总能奏效，因为某些类具有额外的功能，例如，LinkList具有在list接口中未包含的方法，而treeMap也具有在Map中
    未包含的方法。如果你需要使用这些方法，就不能将它们向上转型为更通用的接口。

Collection接口概括了序列的概念----一种存放一组对象的方式。下面这个简单的示例用Integer对象填充了一个Collection
(这里用ArrayList表示)

11.3 添加一组元素
在java.util包中的Arrays和Collections类中都有很多实用的方法，可以在一个Collection中添加一组元素。Arrays.asList()
方法接受一个数组或是一个用逗号分割的元素列表（使用可变参数），并将其转换为一个list对象。Collections.addAll()
方法接受一个Collection对象，以及一个数组或是一个用逗号分割的列表，将元素添加到Collection中。

11.4 容器的打印

11.5 List
List承诺可以将元素维护在特定得序列中。List接口在Collection得基础上添加了大量的方法。使得可以在List的中间插入和移除元素。
有两种类型的List:
基本的ArrayList，它长于随机访问元素，但是在List的中间插入和移除元素时较慢。
LinkedList，它通过代价较低的在List中间进行插入和删除操作，提供了优化的顺序访问。LinkeList在随机访问方面相对较慢，但是它的
特性集较ArrayList更大。

11.6 迭代器
任何容器类，都必须有某种方式可以插入元素并将它们再次取回。毕竟，持有事物是容器的基本工作。对于List,add()是插入元素的方法之一，而get()是取出元素的方法之一。
如果从更高层的角度思考，会发现这里有个缺点：要使用容器，必须对容器的确切类型编程。初看起来这没什么不好，但是考虑下面的情况：如果原本是对着List编码的，但是后来发现如果能够把相同的代码应用于set，将会显得非常方便，此时，应该怎么做？或者打算从头开始编写通用的代码，它们只是使用容器，不知道或者说不关心容器的类型，那么如何才能不重写代码就可以应用于不同类型的容器？
迭代器（也是一种设计模式）的概念可以用于达成此目的。迭代器是一个对象，它的工作是
遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构。此外，迭代
器通常被称为轻量级对象：创建它的代价小。因此,经常可以见到对迭代器有些奇怪的限制；例如：java的Iterator只能单向移动，这个Iterator只能用来
1）使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列的第一个元素。
2）使用next()获得序列中的下一个元素 。
3）使用hasNext()检查序列中是否还有元素。
4）使用remove()将迭代器新近返回的元素删除。
有了Iterator就不必为容器中元素的数量操心了，那是由hasNext()和next()关心的事情。
如果你只是向前遍历List,并不打算修改List对象本身，那么你可以看到foreach语法会显得更加简洁。
Iterator还可以移除由next()产生的最后一个元素，这意味着在调用remove()之前，必须先调用next()。
接受对象容器并传递它，从而在每个对象上都执行操作，这种思想十分强大，并且贯穿于本书。

11.6.1 ListIterator
ListIterator是一个更加强大的Iterator的子类型，它只能用于各种List类的访问。尽管Iterator只能向前移动，但是ListIterator可以双向移动。
它还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以使用Set()方法替换它访问过的最后一个元素。你可以通过调用listIterator()方法产生一个指向List开始处的ListIterator，并且还可以通过调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator.

11.7 LinkedList
LinkedList也像ArrayList一样实现了基本的List接口，但是它执行某些操作(在List的中间插入和移除)时比ArrayList更高效，但在随机访问操作却要逊色一些。
LinkedList还添加了可以使其作用栈、队列或双端队列的方法。
这些方法中有些彼此之间只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加实用(特别是在Queue中)。例如，getFirst()和element()完全一样，它们都返回列表的头（第一个元素），而并不移除它，如果List为空，则抛出NoSuchElementException。peek()方法与这两个方式只是稍有差异，它在列表为空时则返回null。
removeFirst()与remove()也是完全一样的，它们移除并返回列表的头，而在列表为空时则抛出NoSuchElementException。poll()稍有差异，它在列表为空时返回null。
addFirst()与add()和addLast()相同，它们都将某个元素插入到列表的尾端。
removeLast()移除并返回列表的最后一个元素。

11.8 Stack
“栈”通常是指“后进先出(LIFO)”的容器。有时也被称为叠加栈，因为最后“压入”栈的元素，第一个“弹出”栈。经常用来类比栈的事物是装有弹簧的储放器中的自助托盘，最后装入托盘的总是最先拿出使用的。
LinkedList具有能够直接实现栈的所有功能的方法，因此可以直接将LinkedList作为栈使用，不过，有时一个真正的“栈”更能把事情讲清楚；

11.9 Set
Set不保存重复的元素（至于如何判断元素相同则较为复杂，稍后便会看到）。如果你试图将相同对象的多个实例添加到Set中，那么它就会阻止这种重复现象。Set中最常被使用的是测试归属性，你可以很容易地询问某个对象是否在某个Set中。正因为如此，查找就称为了Set中最重要的操作，因此你通常都会选择一个HashSet的实现，它专门对快速查找进行了优化。
Set具有与Collection完全一样的接口，因此没有任何额外的功能，不想前面两个不同的List。实际上Set就是Collection,只是行为不同。（这是继承与多态思想的典型应用：表现不同的行为。）Set是基于对象的值来确定归属性的。

11.10 Map
将对象映射到其他对象的能力是一种解决编程问题的杀手锏。例如，考虑一个程序，它将用来检查Java的Random类的随机性。理想状态下，Random可以将产生理想的数字分布，但要想测试它，则需要生成大量的随机数，并对落入各种不同范围的数字进行计数。Map可以很容易地解决该问题。