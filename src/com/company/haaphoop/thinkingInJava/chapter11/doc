11 持有对象
如果一个程序只包含固定数量的且其生命周期都是已知的对象，那么这是一个非常简单的程序。
通常，程序总是根据运行时才知道的某些条件去创建新对象。在此之前，不会知道所需对象的数量，甚至不知道
确切的类型。为解决这个普遍的变成问题，需要在任意时刻和任意位置创建任意数量的对象。所以，就不能依靠创建命名的引用来持有每一个对象。
因为你不知道实际上会需要多少这样的引用。
大多数语言都提供某种方法来解决这个基本问题。Java有多种方式保存对象（应该说是对象的引用）。例如前面曾经学习过的数组，它是
编译器支持的类型。数组是保存一组对象的最有效的方式，如果你想保存一组基本类型数据，也推荐使用这种方式。但是数组具有固定的尺寸
，而在更一般的情况中，你在写程序时并不知道将需要多少个对象，或者是否需要更复杂的方式来存储对象，因此数组尺寸固定这一限制
显得过于受限了。
Java的实用类库还提供了一套相当完整的容器来解决这个问题，其中基本的类型是List、Set、Quene和Map。这些对象类型也
称为集合类，但由于Java的类库中使用了Collection这个名字来指代该类库的一个特殊子集，所以我使用了更广泛的术语“容器”
称呼他们。容器提供了完善的方法来保存对象，你可以使用这些工具来解决数量惊人的问题。
容器还有其他一些特性。例如，set对于每个值都只保存一个对象，map是允许你将某些对象与其他一些对象关联起来的关联数组。
java容器类都可以自动地调整自己的尺寸。因此，与数组不同，在编程时，你可以将任意数量的对象放置到容器中，并且不需要担心
容器应该设置多大。
即使在java中没有直接的关键字支持，容器类仍旧是可以显著增强你的编程能力的基本工具。

11.1 泛型和类型安全的容器
使用javaSE5之前的容器的一个主要问题是编译器允许你向容器中插入不正确的类型。例如，考虑一个Apple对象的容器，我们使用
最基本最可靠的容器ArrayList。现在你可以把ArrayList当作“可以自动扩充自身尺寸的数组”来看待。使用ArrayList相当
简单：创建一个实例，用Add()方法插入对象，然后使用get()访问这些对象，此时需要使用索引，就像数组一样，但是不需要
方括号。ArrayList还有一个size方法，使你可以知道已经有多少元素添加了进来，从而不会因为不小心索引越界而引发错误。
在本例中，Apple和Orange都放置在了容器中，然后将它们取出。正常情况下，java编译器会报告警告信息，因为这个示例没有使用
泛型。在这里，我们使用JavaSE5所特有的注解来抑制了警告信息。注解以“@”符号开头，可以接受参数，这里的@SuppressWarnings
注解及其参数表示只有有关“不受检查的异常”的警告信息应该被抑制。

11.2 基本概念
Java容器类类库的用途是“保存对象”，并将其划分为两个不同的概念：
1）Collection。一个独立元素的序列，这些元素都服从一条或多条规则。list必须按照插入的顺序保存元素，而set不能有
重复的元素。queue按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。
2）Map。一组成对的“键值对”对象，允许你使用键来查找值。ArrayList允许你使用数字来查找值，因此在某种意义上讲，它
将数字与对象关联在了一起。映射表允许我们使用另一个对象来查找某个对象，它也被称为“关联数组”。因为它将某些对象
与另一些对象关联在了一起；或者被称为“字典”，因为你可以使用键对象来查找值对象，就像在字典中使用单词来定义一样。
Map是非常强大的编程工具。
    尽管并非总是这样，但是在理想情况下，你编写的大部分代码都是在与这些接口打交道，并且你唯一需要指定所使用
    的精确类型的地方就是在创建的时候。因此，你可以像下面这样创建一个list:
    List<Apple> apples = new ArrayList<Apple>();
    注意，ArrayList已经被向上转型为List,这与前一个示例中的处理方式正好相反。使用接口的目的在于如果你决定去修改
    你的实现，你所需的只是在创建处修改它，就像下面这样：
    List<Apple> apples = new LinkedList<Apple>();
    因此，你应该创建一个具体类的对象，将其转型为对应的接口，然后在其余的代码中都使用这个接口。这种方式并非
    总能奏效，因为某些类具有额外的功能，例如，LinkList具有在list接口中未包含的方法，而treeMap也具有在Map中
    未包含的方法。如果你需要使用这些方法，就不能将它们向上转型为更通用的接口。

Collection接口概括了序列的概念----一种存放一组对象的方式。下面这个简单的示例用Integer对象填充了一个Collection
(这里用ArrayList表示)

11.3 添加一组元素
在java.util包中的Arrays和Collections类中都有很多实用的方法，可以在一个Collection中添加一组元素。Arrays.asList()
方法接受一个数组或是一个用逗号分割的元素列表（使用可变参数），并将其转换为一个list对象。Collections.addAll()
方法接受一个Collection对象，以及一个数组或是一个用逗号分割的列表，将元素添加到Collection中。

11.4 容器的打印

11.5 List
List承诺可以将元素维护在特定得序列中。List接口在Collection得基础上添加了大量的方法。使得可以在List的中间插入和移除元素。
有两种类型的List:
基本的ArrayList，它长于随机访问元素，但是在List的中间插入和移除元素时较慢。
LinkedList，它通过代价较低的在List中间进行插入和删除操作，提供了优化的顺序访问。LinkeList在随机访问方面相对较慢，但是它的
特性集较ArrayList更大。

11.6 迭代器
任何容器类，都必须有某种方式可以插入元素并将它们再次取回。毕竟，持有事物是容器的基本工作。对于List,add()是插入元素的方法之一，而get()是取出元素的方法之一。
如果从更高层的角度思考，会发现这里有个缺点：要使用容器，必须对容器的确切类型编程。初看起来这没什么不好，但是考虑下面的情况：如果原本是对着List编码的，但是后来发现如果能够把相同的代码应用于set，将会显得非常方便，此时，应该怎么做？或者打算从头开始编写通用的代码，它们只是使用容器，不知道或者说不关心容器的类型，那么如何才能不重写代码就可以应用于不同类型的容器？
迭代器（也是一种设计模式）的概念可以用于达成此目的。迭代器是一个对象，它的工作是
遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构。此外，迭代
器通常被称为轻量级对象：创建它的代价小。因此
