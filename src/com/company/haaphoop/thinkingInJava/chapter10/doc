内部类：可以将一个类的定义放在另一个类的定义内部
内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可见性。然而必须要了解
到内部类与组合是完全不同的概念，这一点很重要。

10.1 创建内部类
创建内部类的方式就如同你想的一样，把类的定义置于外围类的里面。更典型的情况是外部类将有一个方法，该方法返回一个
指向内部类的引用，就像在to()和contents()方法中看到的那样。如果想从外部类的非静态方法之外的任意位置创建某个内部
类的对象，那么必须像在main()方法中那样，具体地指明这个对象的类型：OuterClassName.InnerClassName。

10.2 链接到外部类
当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问外围对象的所有成员，而不需要
任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。内部类自动拥有对其外围类所有成员的访问权。当某个外围类的对象创建了
一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，在你访问此外围类的成员时，就是用那个引用
来选择外围类的成员。

10.3 使用.this与.new
如果需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型，这一点在编译期
就被知晓并受到检查，因此没有任何运行时开销。
有时你可能想要告知某些其他对象，去创建其某个内部类的对象。要实现此目的，你必须在new 表达式中提供对其他外部类对象的引用，这
是需要使用.new语法。

10.4 内部类与向上转型
当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。（从实现了某个接口的对象，得到对此接口的引用，与向上
转型为这个对象的基类，实质上效果是一样的。）这是因为此内部类----某个接口的实现----能够完全不可见，并且不可用。所得到的只是指向基类
或接口的引用，所以能够很方便地隐藏实现细节。

10.5 在方法和作用域内的内部类
到目前为止，所看到的只是内部类的典型用途。通常，如果所读/写的代码包含了内部类，那么它们都是平凡的内部类，简单并且容易理解，然而，内部类的
语法覆盖了大量其他的更加难以理解的技术。例如，可以在一个方法里面或者在任何作用域内定义内部类。这么做有两个理由：
1）如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。
2）你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。
下面代码中，来实现：
1）一个定义在方法中的类
2）一个定义在作用域内的类，此作用域在方法的内部
3）一个实现了接口的匿名类
4）一个匿名类，它扩展了有非默认构造器的类
5）一个匿名类，它执行字段初始化
6）一个匿名类，它通过实例初始化实现构造（匿名类不可能有构造器）

10.6 匿名内部类
在匿名内部类末尾得分号，并不是用来标记此内部类结束得。实际上，它标记得是表达式得结束，只不过这个表达式正巧包含了匿名内部类罢了。因此，这与别的
地方使用分号是一致得。

10.6.1 再访工厂方法

10.7 嵌套类
如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常称为嵌套类。想要理解static应用于内部类时得含义，就必须记住，普通内部类对象隐式地保存了一个引用，指向创建它得外围类对象。然而，当内部类是static得时，就不是这样了。嵌套类意味着：
1）要创建嵌套类的对象，并不需要其外围类的对象
2）不能从嵌套类的对象中访问非静态的外围类对象
嵌套类与普通类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类。但是
嵌套类可以包含所有这些东西。

10.7.1 接口内部的类
正常情况下，不能在接口内部放置任何代码，但嵌套类可以作为接口的一部分。你放到接口中的任何类都自动地是public和static的。因为类是static的，只是将
嵌套类置于接口的命名空间内，这并不违反接口的原则。你甚至可以在接口内部类中实现其外围接口。如果想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所公用，那么使用接口内嵌类会显得很方便。

10.7.2 从多层嵌套类中访问外部类的成员
一个内部类被嵌套多少层并不重要-----它能透明地访问所有它所嵌入的外围类的所有成员，如下所示：

10.8 为什么需要内部类
至此，我们已经看到了许多描述内部类的语法与语义，但是这并不能回答“为什么需要内部类”这个问题。那么，Sun公司为什么会如此费心地增加这项基本的语
言特性呢？一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。
内部类唯一要回答的是，如果只是需要一个对接口的引用，为什么不通过外围类实现那个接口呢？答案是：“如果这能满足需求，那么就应该这样做。”那么内部类实现一个
接口与外围类实现这个接口有什么不同呢？答案是后者不是总能享受到接口带来的方便，有时需要用到接口的实现。所以，使用内部类最吸引人的原因是：“每个内部类
都能独立地继承自一个接口的实现，所以无论外围类是否已经继承了某个（接口）的实现，对于内部类都没有影响。”
如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计与编程的问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了
部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（类或抽象类）。
如果不需要解决“多重继承”的问题，那么自然可以用别的方式编码，而不需要使用内部类。但如果使用内部类，还可以获得其他
一些特性：
1）内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。
2）在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。
3）创建内部类对象的时刻并不依赖于外围类对象的创建。
4）内部类并没有令人迷惑的“is-a”关系，它就是一个独立的实体。
举个例子，如果Sequence.java不适用内部类，就必须声明“Sequence是一个Selector”，对于某个特定的Sequence只能有
一个Selector。然而使用内部类很容易就能拥有另一个方法reverseSelector()，它用来生成一个反向遍历序列的Selector
。只有内部类才有这种灵活性。

10.8.1 闭包与回调
闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类
是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，
在此作用域内，内部类有权操作所有的成员，包含private。
Java最引人争议的问题之一就是，人们认为Java应该包含某种类似指针的机制，以允许回调（callback）。通过回调，对象
能够携带一些信息，这些信息允许它在稍后的某个时刻用初始的对象。

10.8.2 内部类与控制框架
在将要介绍的控制框架（control framework）中,可以看到更多使用内部类的具体例子。
应用程序框架（application framework）就是被设计用来解决某类特定问题的一个或一组类。要运用某个应用程序框架，通常
是继承一个或多个类，并覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，以解决你的特定问题。（这是设计模式中
模板方法的一个例子）模板方法包含算法的基本结构，并且会调用一个或多个可覆盖的方法，以完成算法的动作。设计模式总是将变化的事物与保持不
变的事物分离开，在这个模式中，模板方法是保持不变的事物，而可覆盖的方法就是变化的事物。
控制框架是一类特殊的应用程序框架，它用来解决响应事件的需求。主要用来响应事件的系统被称为事件驱动系统。应用程序设计中常见的问题之一是
图形用户接口（GUI）,它几乎完全是事件驱动系统。要理解内部类是如何允许简单的创建过程以及如何使用控制框架的，请考虑这样一个控制框架，它
的工作就是在事件“就绪”的时候执行事件。虽然“就绪”可以指任何事，但在本例中，是指基于事件触发的事件。接下来的问题是，对于要控制什么，控制框架
并不包含任何具体的信息，那些信息是在实现算法的action()部分时，通过继承来实现的。
注意，在目前的设计中，你并不知道Event到底做了什么。这正是此设计的关键所在，“使变化的事物与不变的事物相互分离”。用
我的话说，“变化向量”就是各种不同的Event对象所具有的不同行为，而你通过创建不同的Event子类来表现不同的行为。
这正是内部类要做的事情，内部类允许：
1）控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。内部类用来表示解决问题所必需的各种不
同的action()。
2）内部类能够很容易地访问外围类的任意成员，所以可以避免这种实现变的笨拙。如果没有这种能力，代码将变的令人讨厌
，以至于你肯定会选择别的方法。
考虑此控制框架的一个特定实现，如控制温室的运作：控制灯光，水，温度调节器的开关，以及响铃和重新启动系统，每个行为
都是完全不同的。控制框架的设计使得分离这些不同的代码变的非常容易。使用内部类，可以在单一的类里面产生对同一个
基类Event的多种导出版本。对于温室系统的每一种行为，都继承一个新的Event内部类，    并在要实现的action()中编写控制代码。

